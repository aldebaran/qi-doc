/** \mainpage Qi - a lightweight cross language open source communication framework

\b Qi is a lightweight communication framework for high performance messaging
between distributed processes in memory-constrained environments.

It places the minimum of requirements on your code. We do not wrap your 'main' method
and we do not wrap your message types. This makes it easy to integrate existing libraries
into qi, in most cases without the need to modify the signature of your methods.

Qi was designed with the following goals:
- Simple
- Non-intrusive
- Low memory
- Performance
- Flexible
- Distributed
- Fast compilation

For detailed examples, see the \subpage quickstart , or look at the \subpage cheatsheet for an overview of the API.

This manual is divided in the following sections:
- \subpage overview
- \subpage quickstart
- \subpage cheatsheet
- \subpage advanced
- \subpage style
*/

//-----------------------------------------------------------

/** \page overview Overview

Qi support two major styles of styles of messaging:

\b RPC

Synchronous remote procedure calls. These enable the classic Request-Response
pattern of communication. The server advertises a named handler, then clients can
call the handle using the name.

\image html rpc.png

\b Topics

One to many asynchronous publishing. These enable efficient broadcast of data or
events, typical to message passing architectures. The publisher advertises a named topic
with associated type, then subscribers can declare handlers that receive the data that
is published to the topic.

\image html publish.png
\image html many_to_many.png

\b Transport

Transparently, the optimal communication method is chosen according to your context.

\image html transport.png

\b "Peer-to-peer communication"

A Master Server acts as a directory of services and topics so that processes can find
each other's services. After an initial lookup with the master, all further communication
to a service or topic is peer-to-peer.

\image html master.png


*/

//-----------------------------------------------------------

/** \page quickstart Quick Start

\b Advertise a Service
\code
#include <qi/messaging/server.hpp>

// The handler that you want to bind
int getMeaningOfLife() {
  return 42
}

int main(int argc, char *argv[])
{
  // Create the server, giving it a name that helps to track it
  qi::Server server("deepThought");
  // Add the service, giving it a name.
  server.addService("deepThought.getMeaningOfLife", &getMeaningOfLife);
  // FIXME: need a nice way to sleep
}
\endcode

\b Call a service
\code
#include <qi/messaging/client.hpp>

int main(int argc, char *argv[])
{
  // Create a client giving it a name that helps to track it.
  qi::Client client("user");
  // Call the method, expecting an int as the reply type
  int theMeaningOfLife = client.call<int>("deepThought.getMeaningOfLife");
}
\endcode


*/


//-----------------------------------------------------------

/** \page cheatsheet Cheet Sheet
Overview of API
\code
// Client
qi::Client client;                                        // anonymous
qi::Client client("user");                                // name
qi::Client client("user", "127.0.0.1");                   // name and master address
client.callVoid("methodName", ... args ...);              // up to 9 args
T result = client.call<T>("methodName", ... args ...);    // up to 9 args, return type T

// Server
qi::Server server;                                        // anonymous
qi::Server server("user");                                // name
qi::Server server("user", "127.0.0.1");                   // name and master address
server.addMethod("methodName", &handler);                 // add a global function
server.addMethod("methodName", &object, &Class::handler); // add an object method
server.addMethod("methodName", this   , &Class::handler); // add a method from this class
\endcode



*/

//-----------------------------------------------------------

/** \page advanced Advanced Usage
This page is for advanced users.

*/


/**
\defgroup Messaging Messaging Classes
Messaging classes. Each classes register to a master.

\defgroup Signature Signature Classes
This module generate signature for a specified type. You can take the signature
of most POD and STL types. When protobuf support is compiled in, you can take
the signature of protobuf messages too.

\defgroup Serialization Serialization Classes
This module handle serialization. qi::serialization::Message represent a message
that will be exchanged by Messaging classes.

\defgroup Functors Functors Classes
the Functor class can be created from either a function or an object method, it can
handle a maximum of 9 arguments. This class can be used with a serialization::Message.
It can be called with two Message, one for the request, one for the response.

\defgroup Transport Transport Classes
This module contains single connection transport classes. They allow direct
communication between two endpoint but does not register with a master.

Two communication models are provided, you can use standard client/server connection,
or a publisher/subscriber pattern.

Context management is explicit in the transport module. It's always prefered to have
the same Context between differents transport, this will allow to have more effective
communication, by reusing tcp/ipc connections. ZeroMq inproc transport impose to have
the same context between the client and the server.
*/
