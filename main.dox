/** \mainpage Qi - a lightweight open source communication framework

\b Qi is a lightweight communication framework for high performance messaging
between distributed processes in memory-constrained environments.

It places the minimum of requirements on your code. We do not wrap your 'main' method
and we do not wrap your message types. This makes it easy to integrate existing libraries
into qi, in most cases without the need to modify the signature of your methods.

Qi was designed with the following goals:
- Simple
- Non-intrusive
- Low memory
- High Performance
- Flexible
- Distributed
- Fast compilation

Please continue to the \subpage overview, or dive straight into the \subpage quickstart for code examples.

This manual is divided in the following sections:
- \subpage overview
- \subpage quickstart
- \subpage cheatsheet
- \subpage advanced
- \subpage style
*/

//-----------------------------------------------------------

/** \page overview Overview

Qi supports two major styles of styles of messaging:

\b RPC

Synchronous remote procedure calls. These enable the classic Request-Response
pattern of communication. The server advertises a named handler, then clients can
call the handle using the name.

\image html rpc.png

\b Topics

One to many asynchronous publishing. These enable efficient broadcast of data or
events, typical to message passing architectures. The publisher advertises a named topic
with associated type, then subscribers can declare handlers that receive the data that
is published to the topic.

\image html publish.png
\image html many_to_many.png

\b Transport

Transparently, the optimal communication method is chosen according to your context.

\image html transport.png

\b Discovery

A Master Server acts as a directory of services and topics so that processes can find
each other's services. After an initial lookup with the master, all further communication
to a service or topic is peer-to-peer.

\image html master.png


*/

//-----------------------------------------------------------

/** \page quickstart Quick Start

\b Advertise a Service
\include example_qi_server.cpp

\b Call a service
\include example_qi_client.cpp

\b Advertise a Topic
\include example_qi_publisher.cpp

\b Subscribe to a Topic
\include example_qi_subscriber.cpp
*/


//-----------------------------------------------------------

/** \page cheatsheet Cheet Sheet
Overview of API
\code
// Client
qi::Client client;                                               // default name "client"
qi::Client client("myclient");                                   // name your client
client.connect();                                                // connect to a local master
client.connect("192.168.0.10");                                  // connect to specific master
client.callVoid("methodName", ... args ...);                     // up to 9 args, return type void
T result = client.call<T>("methodName", ... args ...);           // up to 9 args, return type T

// Server
qi::Server server;                                               // default name "server"
qi::Server server("myserver");                                   // name your server
server.connect();                                                // connect to a local master
server.connect("192.168.0.10");                                  // connect to a specific master
server.advertiseService("methodName", &handler);                 // advertise a global function
server.advertiseService("methodName", &object, &Class::handler); // advertise an object method
server.advertiseService("methodName", this   , &Class::handler); // advertise a method from this class
\endcode



*/

//-----------------------------------------------------------

/** \page advanced Advanced Usage
This page is for advanced users.

*/


/**
\defgroup Messaging Messaging
Messaging classes. Each classes register to a master.

\defgroup Signature Signature
This module generate signature for a specified type. You can take the signature
of most POD and STL types. When protobuf support is compiled in, you can take
the signature of protobuf messages too.

\defgroup Serialization Serialization
This module handle serialization. qi::serialization::Message represent a message
that will be exchanged by Messaging classes.

\defgroup Functors Functors
the Functor class can be created from either a function or an object method, it can
handle a maximum of 9 arguments. This class can be used with a serialization::Message.
It can be called with two Message, one for the request, one for the response.

\defgroup Transport Transport
This module contains single connection transport classes. They allow direct
communication between two endpoint but does not register with a master.

Two communication models are provided, you can use standard client/server connection,
or a publisher/subscriber pattern.

Context management is explicit in the transport module. It's always prefered to have
the same Context between differents transport, this will allow to have more effective
communication, by reusing tcp/ipc connections. ZeroMq inproc transport impose to have
the same context between the client and the server.
*/
