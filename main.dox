/** \mainpage Qi - a lightweight open source communication framework

\b Qi is a lightweight communication framework for high performance messaging
between distributed processes in memory-constrained environments.

It places the minimum of requirements on your code. We do not wrap your 'main' method
and we do not wrap your message types. This makes it easy to integrate existing libraries
into qi, in most cases without the need to modify the signature of your methods.

Qi was designed with the following goals:
- Simple
- Non-intrusive
- Low memory
- High Performance
- Flexible
- Distributed
- Fast compilation

Please continue to the \subpage overview, or dive straight into the \subpage quickstart for code examples.

This manual is divided in the following sections:
- \subpage overview
- \subpage quickstart
- \subpage cheatsheet
- \subpage advanced
- \subpage style
*/

//-----------------------------------------------------------

/** \page overview Overview

Qi supports two major styles of styles of messaging:

\b RPC

Synchronous remote procedure calls. These enable the classic Request-Response
pattern of communication. The server advertises a named handler, then clients can
call the handle using the name.

\image html rpc.png

\b Topics

One to many asynchronous publishing. These enable efficient broadcast of data or
events, typical to message passing architectures. The publisher advertises a named topic
with associated type, then subscribers can declare handlers that receive the data that
is published to the topic.

\image html publish.png
\image html many_to_many.png

\b Transport

Transparently, the optimal communication method is chosen according to your context.

\image html transport.png

\b Discovery

A Master Server acts as a directory of services and topics so that processes can find
each other's services. After an initial lookup with the master, all further communication
to a service or topic is peer-to-peer.

\image html master.png


*/

//-----------------------------------------------------------

/** \page quickstart Quick Start

\b Advertise a Service
\include example_qi_server.cpp

\b Call a service
\include example_qi_client.cpp

\b Advertise a Topic
\include example_qi_publisher.cpp

\b Subscribe to a Topic
\include example_qi_subscriber.cpp
*/


//-----------------------------------------------------------

/** \page cheatsheet Cheet Sheet
Overview of API
\code
// Client
qi::Client client;                                               // default name "client"
qi::Client client("myclient");                                   // name your client
client.connect();                                                // connect to a local master
client.connect("192.168.0.10");                                  // connect to specific master
client.callVoid("methodName", ... args ...);                     // up to 9 args, return type void
T result = client.call<T>("methodName", ... args ...);           // up to 9 args, return type T

// Server
qi::Server server;                                               // default name "server"
qi::Server server("myserver");                                   // name your server
server.connect();                                                // connect to a local master
server.connect("192.168.0.10");                                  // connect to a specific master
server.advertiseService("methodName", &handler);                 // advertise a global function
server.advertiseService("methodName", &object, &Class::handler); // advertise an object method
server.advertiseService("methodName", this   , &Class::handler); // advertise a method from this class
\endcode



*/

//-----------------------------------------------------------

/** \page advanced Advanced Usage
This page is for advanced users.

*/


/**
\defgroup Messaging Messaging
The messaging classes provide the main entry point for users of qi::messaging.
Each class registers with a master upon connection, and uses the master to
advertise its capacities or discover the capacities of other classes in the qi
network. The first lookup of a service will interogate the master for the location
of the service server, then the client will communicate directly with that server.

\defgroup Signature Signature
This module generates signatures for specified types. It can take the signature
of most POD and STL types. When protobuf support is compiled in, you can take
the signature of protobuf messages too.

\defgroup Serialization Serialization
This module handles serialization or arguments and return types to and from messages.
The qi::serialization::Message is used by the transport layer to exchange information
between messaging classes.

\defgroup Functors Functors
The Functor class can be created from either a function or an object method and can
handle a maximum of 9 arguments. This class can be used with a serialization::Message.
It can be called with two Messages, one for the request, one for the response.

\defgroup Transport Transport
This module contains single connection transport classes. They allow direct
communication between two endpoints but do not require registration with a master.

Two communication models are provided: standard client/server connection,
or a publisher/subscriber pattern.
Context management is explicit in the transport module. It is always prefered to have
the same Context between differents transport, this allows more effective
communication, by reusing tcp/ipc connections. ZeroMq inproc transport requires that
the same context is shared between clients and the servers.

\defgroup qiCapi qi C API
simple C API for qi. This API is recommanded if you want extreme ABI compatibility.
This include client, server, message and signature.
*/
